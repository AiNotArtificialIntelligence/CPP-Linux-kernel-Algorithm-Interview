# Linux内核设计与实现

## 进程管理

进程退出后被设置成僵死状态，直到他的父进程调用wait()或waitpid()函数



linux通过slab分配器分配task_struct结构体，这样能达到**对象复用和缓存着色**的目的，（通过预先分配和重复使用task_struct，可以避免动态分配和释放所带来的资源消耗-------*所以有一块专门的用于分配task_struct结构体的缓冲区*，是task_struct_cache）



thread_info结构体在内核栈的尾端分配，想想那三个重要数据结构（内核栈、thread_info、task_struct）的关系



内核通过PID标识每个进程，PID类型是pid_t，其实就是int，所以内核最多支持的进程数就是int的最大值



current宏访问task_struct结构体，实现过程和体系结构相关，寄存器多的可能直接放到一个寄存器中，而寄存器少的（如X86）只能通过在内核栈尾端创建thread_info结构体，间接地查找task_struct。ARM64中：通过sp_el0寄存器得到task_struct结构体的地址。ARM32中：通过thread_info得到task_struct结构体，想想那三个数据结构的图，thread_info是和内核栈在一起的，所以内核栈是可以找到的，这样thread_info的位置其实也是确定的（**对内核栈的栈指针进行一下内存对齐**），故可以找到



进程状态：TASK_RUNNING运行状态、TASK_INTERRUPTIBLE可中断，被阻塞、TASK_UNINTERRUPTIBLE不可中断，TASK_ZOMBIE僵死，进程结束但是父进程还没有调用wait()，此时这个进程地task_struct还保留着、TASK_STOPPED停止-------------可以使用set_task_state函数设定状态



进程上下文，当程序触发系统调用或者触发了某异常陷入内核，此时内核“代表进程执行”并处于进程上下文中，，在此上下文中**cureent宏是有效**的，，，除了进程上下文，还有中断上下文，中断上下文中，系统不代表进程执行，而是执行一个中断处理程序，不会有进程去干扰这些中断处理程序，所以不会存在进程上下文



每个进程必有一个父进程，task_struct中有指向父进程的parent指针，和指向子进程的children指针，和指向兄弟进程的sibling指针



fork、vfork和__clone都调用的是clone系统调用，clone系统调用会调用do_fork，，do_fork中**copy_process**是复制进程，**wake_up_new_task**是唤醒，，，，过程是调用dup_task_struct创建内核栈、thread_info和task_struct(这个可以说一下从缓冲区直接分配)，这些值与父进程相同，，，，然后设置状态为TASK_UNINTERRUPTIBLE确保不会运行，，，，然后调用get_pid()创建一个有效的PID，，，然后根据clone系统调用参数标志拷贝或共享打开的文件、文件系统信息、进程地址空间等（copy_mm?），，，然后唤醒----------------------**内核会先选择子进程执行，因为子进程一般马上调用exec()函数，可以避免写时复制带来的开销**



do_fork中的copy_mm可以分为3钟情况：

1 如果是内核线程，mm指针为null，直接退出，每次调度到内核线程时，会借用上一个进程的mm结构，放在active_mm中

2 如果不是内核线程，并且设置了CLONE_VM（表示父子进程共享地址空间） flag,则说明是个用户线程，共享父进程的运行空间，所以把父进程的mm赋值给子线程

3 如果以上情况都不是，那么新建的肯定是个进程，有独立的运行空间，所以需要新建自己的mm_struct结构，linux基于写时复制的原则，先复制父进程的页表。



vfork()和fork()不同的是vfork不会拷贝父进程的页表项，子进程作为父进程的一个线程在他的地址空间运行，父进程被阻塞，直到子进程退出或执行exec()



wait这一族的函数都是通过唯一的系统调用wait4()实现的，标准动作是**挂起**调用它的进程（所以为了父进程不挂起，可以在子进程退出后发送一个信号，父进程接受到信号之后再调用wait函数），直到其中一个子进程退出



## 进程调度

多任务系统可以划分两类：抢占式多任务（进程在被抢占之前能运行的时间是设定好的，就是时间片）和非抢占式多任务



当一个进程进入TASK_RUNNING状态，内核会检查其优先级是否大于正在执行的进程，如果是，调度程序会被唤醒，抢占当前正在运行的进程并运行新的可运行进程。另外，当一个进程的时间片变为0是，它会被抢占，调度程序被唤醒一选择一个新的进程



runqueue运行队列结构体，是给定处理器上的可执行进程的链表，每个处理器一个，，，对可执行队列执行操作以前，应该先上锁



优先级位图，这样只需要找位图中被设置为1的第一个位



重新计算时间片：许多操作系统（包括老版本的Linux）在所有的进程时间片用完之后，循环访问每个进程计算时间片，，，，新的Linux为每个处理器维护两个优先级数组，既有活动数组（就是上面说的位图）也有过期数组，当一个进程时间片耗尽切换到过期数组时，它需要的时间片已经计算好了，所以不用循环遍历计算时间片



负载平衡程序load_balance有两种调用方法：在schedule执行的时候，只要当前可执行队列为空，就调用load_balance。系统空闲时每隔1毫秒调用一次会长子啊其他情况下每隔200毫秒调用一次



用户抢占在以下情况发生：从系统调用返回用户空间。从中断处理程序返回用户空间。。。。会检查need_resched标志



内核抢占，thread_info中的preempt_count计数器，初始为0，使用锁加1，释放锁减1.数值为0时，可抢占

## 系统调用

在Linux中，系统调用是用户空间访问内核的唯一手段，除异常和中断陷入外，它们是内核唯一的合法入口。其他的像设备文件和/proc之类的方式，最终也是通过系统调用实现的。



用户空间的进程执行一个系统调用通过系统调用号来执行，进程不会体积系统调用的名称，内核记录了所有已注册的系统调用列表，存储在sys_call_table中。这个表为每一个系统有效的系统调用指定了唯一的系统调用号。



系统调用，通知内核的机制是通过**软中断**实现的，通过引发一个**异常**来促使系统切换到内核态去执行异常处理程序，X86系统中系统调用号通过eax寄存器传递给内核，也用来传递给用户空间的返回值



向用户空间写数据，copy_to_user(目的地址，源地址，需要拷贝的数据长度)   从用户空间读数据，copy_from_user()



将系统调用号和参数压入寄存器并触发软中断来陷入内核

## 中断和中断处理程序

中断机制----------变内核主动为硬件主动（让硬件需要的时候向内核发出信号，而不是内核阻塞等待硬件执行或者轮询硬件的状态）



中断 是一种电信号，由硬件设备产生，并直接送入**中断控制器**的输入引脚。然后中断控制器向处理器发送相应的信号，处理器检测到信号便中断当前工作转而处理中断，，，异常在产生时必须考虑与处理器时钟同步，常被称为同步中断，异常是处理器主动发出的



每个中断都有一个中断处理处理程序（ISR），若一个设备可以产生多种不同的中断，那么该设备就对应多个不同的中断处理程序，相应的，该设备的驱动程序也就需要准备多个相应的ISR



上半部与下半部：中断处理程序是上半部，如对接受的中断进行应答或复位，这些工作都是在**所有中断被禁止**的情况下完成的（即上半部执行的时候会关中断？？？）   例如：网卡，中断开始，应答硬件，拷贝最新的网络数据包到内存，然后读取网卡更多的数据包（这些是上半部？）处理和操作数据包的其他工作后续执行（下半部）



通过request_irq()注册并激活一个中断处理程序，，，，request_irq()函数可能会**睡眠**，不允许在中断上下文或者其他不允许阻塞的代码中调用这个函数。。。原因，reques_irq在注册过程中会调用proc_mkdir()创建一个procfs项，而且会调用proc_create()函数对procfs项进行设置，proc_create()会调用kmalloc()分配内存，**kmalloc是可以睡眠**的



free_irq()释放中断处理程序



当一个给定的中断处理程序在执行时，相应的中断线在所有其他处理器都会被屏蔽掉，，所以，同一个中断处理程序**不会被同时调用**以处理嵌套的中断



中断处理程序没有自己的栈，它们共享所中断进程的内核栈



分下半部的原因，尽量减少ISR工作量，因为它运行的时候当前的中断线在所有处理器上都会被屏蔽。。。。。下半部执行的时候，可以执行所有的中断。。。。。上半部就是指的是ISR？	



软中断和tasklet是一种下半部机制，，，软中断是一组**静态定义**的下半部接口，有32个，可以在所有处理器上同时执行，即使**类型相同也可以**，，，tasklet是基于软中断实现的、动态创建的下半部机制，，，，，，，，，，软中断在编译期间静态注册，taskleft可以在执行期间动态注册



通过软中断、tasklet、工作队列实现下半部（与此无关，内核定时器也可以实现推后工作，但是内核定时器是在未来某个确定的时间执行工作）



创建tasklet，可以静态创建：DECLARE_TASKLET或	DECLARE_TASKLET_DISABLED



ksoftirqd内核线程，辅助处理软中断和tasklet



工作队列允许被调度或睡眠



|  下半部  | 上下文 |     顺序执行保障     |
| :------: | :----: | :------------------: |
|  软中断  |  中断  |         没有         |
| tasklet  |  中断  | 同类型不能被同时执行 |
| 工作队列 |  进程  |         没有         |



同类的tasklet不会同时运行，所以对于同类tasklet中的共享数据不需要保护，但是当数据被两个不同的tasklet共享时，就需要加普通的自旋锁，这里不用禁止下半部，因为同一个处理器上不会出现tasklet相互抢占的情况-------------------对于软中断，无论是否同种类型，如果数据被软中断共享，必须得到锁的保护，因为同类型的软中断可以同时运行在多个处理器上，没必要禁止下半部，因为同一个处理器上的软中断不会抢占另一个软中断



## 内核同步介绍

临界区就是访问和操作共享数据的代码段



避免并发和防止竞争条件被称为**同步**



TestAndSet指令，原子操作，由硬件保证



可能造成并发的原因：中断、软中断和tasklet、内核抢占、睡眠及与用户空间的同步、对称多处理

## 内核同步方法

原子数据操作------原子位操作



 原子整数atomic_t数据，常见用途是计数器，，原子操作如atomic_add()\atomic_read()等**只保证原子性，不保证顺序性，顺序性通过屏障指令**来实施



原子位操作，set_bit()、clear_bit()、test_and_set()等，只要指针指向了想操作的任何数据，就可以原子的进行操作。。。。另外还有**非原子操作**，它不保证原子性，且名字前缀比原子操作多两个下划线，如__test_and_set()，用途是，**如果已经用锁保护住了自己的数据结构，用非原子操作可能比原子操作快**



经常会碰到的情况，先从一个数据结构移出数据，然后把它加入到另一个数据结构中去，整个过程必须是原子的-----------------------------这种情况下，简单的原子操作就无能为力了，所以需要更复杂的同步方法，锁



加锁机制，一种是得不到锁就忙等（自旋锁），一种是得不到锁就阻塞（信号量实现了这种机制）



自旋锁可以在中断处理程序中使用，此处**不可以使用信号量**，因为信号量会导致**睡眠**



读写锁，，，rwlock_t类型，使用的话，read_lock()、read_unlock()、write_lock()、write_unlock()

```C++
rwlock_t mr_rwlock = RW_LOCK_UNLOCKED;

//一个线程中
read_lock(&mr_rwlock);
write_lock(&mr_rwlock);//就是不要把读锁升级成写锁，这样会死锁，因为写锁会不断自选
```



Linux中的信号量是一种**睡眠锁**，若有一个任务试图获得一个已经被占用的信号量时，信号量会将其推进一个等待队列，然后让其睡眠



**中断上下文中只能使用自旋锁，任务睡眠时只能使用信号量**



BKL大内核锁，全局自旋锁，主要为了方便实现从Linux最初的SMP过滤到细粒度加锁机制



seq锁，用于读写共享数据，主要依靠一个序列计数器，当有疑义的数据被写入时，会得到一个锁，且序列值增加。在读取数据之前和之后，若序列号相同说明没有被写操作打断过。相对于读写锁，这个**seq锁对写者更有利**，只要没有其他写者，写锁总是可以成功获得



preemp_disable()函数增加抢占计数值，从而**禁止内核抢占**



处理多处理器或硬件设备之间的同步问题时，可能需要保证读写数据的顺序性。使用**屏障指令来保证顺序性**，



**rmb()读内存屏障**，确保跨越rmb()的载入动作不会发生重排序，即rmb之前的载入动作不会重新排在该调用之后，rmb之后的载入动作不会重新排在该调用之前，同理还有**wmb()写内存屏障**，还有**mb()**既提供了写屏障也提供了读屏障

```C++
//thread1
a = 3;
mb();
p = &a;
//thread2
pp = p;
read_barrier_depends();
b = *pp;
//如果没有内存屏障，有可能在pp被设置成p前，b就被设置成pp了
//重排序的发生是现代处理器为了优化传送管道，打乱了分派和提交指令的顺序
//宏smp_rmb()、spm_wmb()、smp_mb()和read_barrier_depends()
```



这些指令和rmb、wmb这些有什么联系呢？

| 指令名 |                           功能描述                           |
| :----: | :----------------------------------------------------------: |
|  DMB   | 数据存储器隔离。DMB 指令保证： 仅当所有在它前面的存储器访问操作都执行完毕后，才提交(commit)在它后面的存储器访问操作。 |
|  DSB   | 数据同步隔离。比 DMB 严格： 仅当所有在它前面的存储器访问操作都执行完毕后，才执行在它后面的指令 |
|  ISB   | 指令同步隔离。最严格：它会清洗流水线，以保证所有它前面的指令都执行完毕之后，才执行它后面的指令。 |



## 定时器和时间管理

全局变量jiffies记录自系统启动以来产生的节拍数，每次中断就加以，所以秒数就是jiffies/Hz

## 内存管理

page结构体中，flag存放页的状态（包括页是否是脏页、是不是被锁在内存中），_count(atomic_t类型，就那个原子的数)存放引用计数，virtual域是页的虚拟地址



一个页可以由**页缓存**使用，这时，mapping域指向和这个页关联的address_space对象，或者作为私有数据（由private指向），或者作为进程页表中的映射



ZONE_DMA、ZONE_NORMAL、ZONE_HIGHMEM，内核并不能对所有页一视同仁，有些页位于内存中特定物理地址上，所以用于一些特殊的任务，，，用zone结构体描述，其中free_pages是区中空闲页的数目



分配页的接口核心函数是alloc_pages(unsigned int gfp_mask, unsignd int order)，该函数分配2的order次方个连续的物理页，并返回指向第一个页的page结构体的指针，，__get_free_pages()函数也是分配页，不过返回的是所请求的第一个页的逻辑地址



get_zeroed_page()函数，获得一个全部填充为0的地址--------------返回用户空间的页如果不全置零，那么包含的是本来就有的信息，这些信息有可能是垃圾，也有可能包含关键信息



如果要分配页，可以使用上面的那些函数，但是如果要以字节为单位分配**内核内存**的话，可以使用kmalloc()----------------------**分配失败的话返回NULL，必须要检查是否分配成功（所以malloc（）也是一样需要检查吧？）**



gfp_mask标志，分三类：行为修饰符（行为，比如中断处理程序在分配内存时不能睡眠）、区修饰符（在哪个区zone分配）及类型（将前面俩进行了一下组合）



**不能给__get_free_pages()或kmalloc()指定_GFP_HIGHMEM，因为这两个函数返回的是逻辑地址，而不是page结构，这两个函数分配的内存当前有可能还没有映射到内核的虚拟地址空间，因此也可能根本就没有逻辑地址。只有alloc_page()才能分配高端内存**



vmalloc()域kmalloc不同kmalloc分配的地址在虚拟地址空间上是连续的在物理上也是，，，而vmalloc在虚拟地址空间上是连续的，在物理地址空间上可以不连续--------------------------使用vmalloc一般是为了获得大块内存，因为它的物理地址是不连续的，就需要对每个获得的页一个一个的进行映射，可能会导致比直接内存映射大得多的TLB抖动



slab分配器扮演了**通用数据结构缓存层**的角色（为了便于对数据结构的频繁的分配和回收，通常使用一个空闲链表，需要时分配，释放时放回，，，面临的主要问题之一是不能**全局控制**，可用内存紧缺时，内核无法通知每个空闲链表让它收缩缓存大小释放一些内存出来）



slab层把不同的对象划分为**高速缓存组**，每个高速缓存组都存放不同类型的对象-------kmalloc()接口建立在slab层上，使用一组通用的高速缓存，，，然后这高速缓存又被划分为slab，slab由一个或多个连续的物理页组成，每个slab包含一些对象成员，有三种状态：满、部分满或空，



每个高速缓存使用kmem_cache_t结构表示，有三条链表，分别表示满、部分满和空的队列，这些链表包含高速缓存中的所有slab（使用slab结构体描述），，，分配时，优先从部分满的slab中分配，若没有，就从空的分配，再没有，就分配新的slab，分配新的slab通过__get_free_pages()页分配器进行分配



slab只有当给定的高速缓存中既没有部分满也没有空的slab时才调用页分配函数；；；只有当内存紧缺系统试图释放更多内存以供使用，或者高速缓存显式销毁的时候，才调用释放函数



kmem_cache_create()创建一个高速缓存

## 虚拟文件系统VFS

文件、目录、索引节点和挂载点

VFS有四个主要对象类型：**超级块对象**，代表一个已经安装的文件系统，**索引节点对象**代表一个文件，**目录项对象**，代表一个目录项，是路径的一个组成部分，**文件对象**代表由进程打开的文件(VFS将目录作为一个文件处理，所以不存在目录对象)



超级块对象，存储特定文件系统的信息，通常对应于存放在磁盘特定扇区中的文件系统超级块或文件系统控制块，由super_block结构体表示，它有一个域s_op，指向超级块的操作函数表------------索引节点对象inode包含了内核再操作文件或目录时需要的全部信息，一个inode代表一个文件，同超级块操作一样，索引节点对象中有个inode_operations项，描述了VFS用以操作索引节点对象的所有方法（由文件系统实现）----------目录项对象，有个目录项缓存------------------文件对象，**多个进程可以同时打开和操作同一文件，所以同一个文件也可能存在多个对应的文件对象**，操作域有open、read等



有三个数据结构将VFS层和系统的进程联系在一起，它们是：**file_struct、fs_struct和namespace**，file_struct结构体由进程描述符中的file域指向，所有与每个进程相关的信息如打开的文件及文件描述符都包含在其中，这个结构体中fd数组指针指向已打开的文件对象链表（默认32，如果打开文件过多，内核会分配一个新的数组，将fd指向它）。fs_struct结构体由进程描述符的fs域指向，它包含文件系统和进程相关的信息。namespace结构体由进程描述符中的namespace域指向

## 块I/O层

系统能随机访问固定大小数据库（chunk）的设备称为块设备，这些数据片就称为块------------比如硬盘、软盘驱动器、CD-ROM驱动器、闪存等，它们是以**安装文件系统**的方式使用的，，，，另一种设备是字符设备，字符设备按照**字符流**的方式进行访问，，比如串口和键盘---------------------------------所以，区分块设备和字符设备的根本在于**是否能够随机访问**



物理磁盘寻址是按扇区进行的，但是内核执行的所有磁盘操作都是按照块进行的。由于扇区是设备的最小可寻址单元，所以块必能比扇区小，只能数倍于扇区



块调入内存要缓存在一个缓冲区中，每个缓冲区与一个块对应，每个缓冲区都有一个对应的描述符，用buffer_head表示，叫做缓冲区头，这个有俩弊端：缓冲区头很大且不容易控制，其次，它仅能描述单个缓冲区



目前内核中块I/O的基本容器由bio结构体表示，这个结构体代表了正在现场（活动的）以片段（segment）链表形式组织的块I/O操作，一个片段是一块连续的内存缓冲区



块设备将它们挂起的块I/O请求保存在**请求队列**中，用request_queue结构体表示



如果简单地以内核产生请求的次序直接将请求发向块设备的话，性能难以让人接受----------------------------为了优化寻址操作，内核既不会简单的按请求接受次序，也不会立即将其提交给磁盘，而会在提交前，先执行名为**合并**与**排序**的预操作--------在内核中负责提交I/O请求的子系统称为I/O调度程序--------------电梯调度，尽量按一个方向排列---------------最终期限I/O调度程序（为解决Linus电梯所带来的饥饿问题）---------------预测I/O调度程序（基础是最终期限调度程序）-------------完全公正的排队I/O调度程序（把进入I/O请求放入特定队列，以时间片轮转调度队列）---------------------空操作的I/O调度程序（只进行合并）

## 进程地址空间

进程未初始化的全局变量信息存储在bss段，也就是bss的零页，页面中信息全部为0值，所以可用于映射bss段等目的



mm_struct中mmap和mm_rb这两个数据结构描述的对象是相同的：该地址空间中的全部内存区域，mmap使用链表形式，方便简单、高效的遍历所有元素，mm_rb使用红黑树，适合查找



所有的mm_struct结构体都通过自身的mmlist域连接在一个双向链表中，该链表的首元素是init_mm内存描述符，代表init进程的地址空间-----------操作该链表时要使用mmlist_lock锁防止并发访问



vm_area_struct中的vm_mm域指向和VMA相关的mm_struct结构体，每个VMA对其相关的mm_strcut结构体来说都是唯一的。VMA标志在vm_flags域中，标志了内存区域所包含的页面的行为和信息，比如进程的代码映射区没有写权限(VM_WRITE)



可以使用/proc文件系统和pmap工具查看给定进程的内存空间和其中所含的内存区域

```shell
cat /proc/<pid>/maps
#########
pmap pid
```



mmap()和do_mmap()，内核使用do_mmap创建一个新的线性地址空间，但是不一定是创建新的VMA，因为如果创建的新的地址区间能和已经存在的进行合并，且具有相同访问权限，那么会合并成一个。do_mmap()中的file参数是NULL的话，就是**匿名映射**，否则是**文件映射**，，，用户空间通过mmap系统调用调用do_mmap功能



操作和检索页表时必须使用page_table_lock锁，该锁在相应的进程描述符中



一个物理页可能由多个不连续的物理磁盘块组成，因此不能用设备名和块号来做页高速缓存的索引---------------------linux页高速缓存使用address_space结构体描述页高速缓存中的页面，--------------每个address_space都有唯一的基（R）树，保存在page_tree结构体中，基树是一棵二叉树，只要指定文件偏移量就可以在基树中迅速检索到希望的数据



pdflush将脏页写回磁盘

## 模块

